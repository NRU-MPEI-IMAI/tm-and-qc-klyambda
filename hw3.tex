\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage[margin=3cm]{geometry}
\usepackage{paralist}
\usepackage{amsthm, amsmath, amsfonts, amssymb}
\usepackage{mathtools} % \mathclap
\usepackage{bm}
\usepackage{dsfont}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{multirow}
\usepackage{comment}
\usepackage{xcolor, colortbl}
\usepackage{xifthen, xspace}
\usepackage{caption, subcaption}
\usepackage{lscape}
\usepackage{braket}
\usepackage{epigraph}
\usepackage{sectsty}
\usepackage{listings}
\usepackage{minted}
\usepackage[braket, qm]{qcircuit}
\usepackage{graphicx}


\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=blue,
    pdftitle={Overleaf Example},
    pdfpagemode=FullScreen,
    }

\title{Теоретические модели вычислений \\
ДЗ №3: Машины Тьюринга и квантовые вычисления}

\date{1 мая 2022 года}

\begin{document}

\maketitle

\section{Машины Тьюринга}

Работу требуется выполнять в системе \url{turingmachine.io}. \\\\
Для сдачи заданий 1-2 требуется прикрепить файлы YAML с исходным кодом проекта. Каждый файлы должен иметь наименование задание\_пункт.yml, к примеру 1\_1.yml для первой задачи первого задания. \\\\

\subsection{Операции с числами}

Реализуйте машины Тьюринга, которые позволяют выполнять следующие операции:
\begin{enumerate}
    \item Сложение двух унарных чисел (1 балла)
    \\Алгоритм унарного сложения: \\1. Удаляем единицу первого числа и заменяем + на 1.
    \item Умножение унарных чисел (1 балл)
\end{enumerate}
Алгоритм унарного умножения:
\begin{enumerate}
    \item Добавляем знак равенства после второго числа и возвращаемся в начало первого числа

    \item Заменяем единицу на A (тем самым определяем, какие единицы первого числа уже использованы) и идем до второго числа (после знака x)
    
    \item Заменяем единицу на B (тем самым определяем, какие единицы второго числа уже использованы) и добавляем единицу после знака равенства. Идем обратно ко второму числу, пока не встретим B. Повторяем этот пункт, пока не будут перебраны все единицы второго числа и скопированы за знаком равенства. 
    
    \item Заменяем все символы B на единицы, идем обратно к первому числу, пока не встретим символ A, и сдвигаем головку вправо. Если встретим единицу переходим в пункт 2, тем самым пока перебираем все единицы первого числа. Если встретим знак умножения, то удаляем первые два числа, знаки умножения и равенства, оставив только результат. 
\end{enumerate}

\newpage
\subsection{Операции с языками и символами}

Реализуйте машины Тьюринга, которые позволяют выполнять следующие операции:
\\\\1. $\textbf{Принадлежность к языку}$ $L = \{ 0^n1^n2^n \}, n \ge 0$ (0.5 балла)
    
Для слов, принадлежащих языку, будем выводить символ T, в противном случае - F.\\
Алгоритм:
\begin{enumerate}
    \item Рассматриваем слова, в которых первый символ пустой или 0, иначе слово не принадлежит языку.
    \item Заменяем 0 на символ A, переходим в состоянием $replace_1$.
    \item В состоянии $replace_1$ если встретим следующие символамы, то слово не принадлежит языку: 2, С, пустой символ. Пропускаем символы 0 и B. Заменяем 1 на символ B, переходим в состояние $replace_2$.
    \item В состоянии $replace_2$ если встретим пустой символ или 0, то слово не принадлежит языку. Пропускаем символы 1 и C. Заменяем 2 на символ C. Возвращаемся обратно, до тех пор, пока не встретим символ A.
    \item Если символ справа от A это 0 (остались еще нули), то переходим в пункт 2. Если - B, то значит, что все нули закончились, соответственно если слово принадлежит языку, то и 1 и 2 должны закончиться. 
    \item Начиная самого левого символа удаляем символы A, B, C. Если все символы закончились, значит слово принадлежит языку. Если при чтении очередного символа получили 0, 1 или 2, то значит, слово не принадлежит языку. 
\end{enumerate}
 
 
\\\\2. $\textbf{Проверка соблюдения правильности скобок в строке (минимум 3 вида скобок)}$ (0.5 балла)

\begin{enumerate}
    \item Если всретим закрывающую скобку, то заканчиваем. Иначе ищем открывающую скобку и помечаем эту скобку буквой A и ищем закрывающую скобку этого же типа, двигаясь направо. Если не нашли открывающую и закрывающую скобки, то это значит, что мы перебрали все слово, тогда удаляем все слово и пишем символ T.
    \item Если достигли пустого слова, то слово не принадлежит языку. Иначе помечаем найденную закрывающую скобку буквой A и идем к началу. Переходим к пункту 1.
\end{enumerate}


\\\\3. $\textbf{Поиск минимального по длине слова в строке (слова состоят из символов 1 и 0 и разделены пробелом)}$ (1 балл)
\begin{enumerate}
    \item 
    \item 
\end{enumerate}




\section{Квантовые вычисления}

Для выполнения заданий по квантовым вычислениям требуется QDK. Его можно скачать здесь: \url{https://docs.microsoft.com/en-us/azure/quantum/install-overview-qdk}. 
\\\\
Но можно использовать любой пакет, типа \url{https://qiskit.org/}. 
\\\\
В качестве решения задачи надо предоставить схему алгоритма для частного случая при фиксированном количестве кубитов и фиксированных состояниях. 


\subsection{Генерация суперпозиций 1 (1 балл)}

Дано $N$ кубитов ($1 \le N \le 8$) в нулевом состоянии $\Ket{0\dots0}$. Также дана некоторая последовательность битов, которое задаёт ненулевое базисное состояние размера $N$. Задача получить суперпозицию нулевого состояния и заданного.

$$\Ket{S} = \frac{1}{\sqrt2}(\Ket{0\dots0} +\Ket{\psi})$$

То есть требуется реализовать операцию, которая принимает на вход:

\begin{enumerate}
    \item Массив кубитов $q_s$
    \item Массив битов $bits$ описывающих некоторое состояние $\Ket{\psi}$. Это массив имеет тот же самый размер, что и $qs$. Первый элемент этого массива равен $1$.
\end{enumerate}


\begin{minted}[mathescape,
               linenos,
               numbersep=5pt,
               gobble=2,
               frame=lines,
               framesep=2mm]{python}
    def Solve1(qs, psi):
        global circuit
        # применяем оператор Адамара для первого кубита
        circuit.h(0) 
        circuit.barrier()
        # для всех единичных кубитов применяем оператор CNOT с первым
        for i in range (1, len(psi)):
            if psi[i] == 1: circuit.cx(qs[0], qs[i])
\end{minted}

$\psi = \Ket{1010110}$
\Qcircuit @C=1.0em @R=0.2em @!R { \\
	 	\nghost{{qs}_{0} : \ket{{0}} } & \lstick{{qs}_{0} : \ket{{0}} } & \gate{\mathrm{H}} \barrier[0em]{6} & \qw & \ctrl{2} & \ctrl{4} & \ctrl{5} & \qw & \qw\\
	 	\nghost{{qs}_{1} : \ket{{0}} } & \lstick{{qs}_{1} : \ket{{0}} } & \qw & \qw & \qw & \qw & \qw & \qw & \qw\\
	 	\nghost{{qs}_{2} : \ket{{0}} } & \lstick{{qs}_{2} : \ket{{0}} } & \qw & \qw & \targ & \qw & \qw & \qw & \qw\\
	 	\nghost{{qs}_{3} : \ket{{0}} } & \lstick{{qs}_{3} : \ket{{0}} } & \qw & \qw & \qw & \qw & \qw & \qw & \qw\\
	 	\nghost{{qs}_{4} : \ket{{0}} } & \lstick{{qs}_{4} : \ket{{0}} } & \qw & \qw & \qw & \targ & \qw & \qw & \qw\\
	 	\nghost{{qs}_{5} : \ket{{0}} } & \lstick{{qs}_{5} : \ket{{0}} } & \qw & \qw & \qw & \qw & \targ & \qw & \qw\\
	 	\nghost{{qs}_{6} : \ket{{0}} } & \lstick{{qs}_{6} : \ket{{0}} } & \qw & \qw & \qw & \qw & \qw & \qw & \qw\\
\\ }

\subsection{Различение состояний 1 (1 балл)}

Дано $N$ кубитов ($1 \le N \le 8$), которые могут быть в одном из двух состояний:

$$\Ket{GHZ} = \frac{1}{\sqrt2}(\Ket{0\dots0} +\Ket{1\dots1})$$
$$\Ket{W} = \frac{1}{\sqrt N}(\Ket{10\dots00}+\Ket{01\dots00} + \dots +\Ket{00\dots01})$$

Требуется выполнить необходимые преобразования, чтобы точно различить эти два состояния. Возвращать $0$, если первое состояние и 1, если второе. 
\\\\

\begin{enumerate}
    \item Первое состояние: при измерении все кубиты равны 0 или 1.
    \item Второе состояние: при измерении только один кубит равен 1, остальные равны 0
\end{enumerate}

При N = 1 различить состояния невозможно (в этом случае - $\Ket{W}$)

\begin{minted}[mathescape,
               linenos,
               numbersep=5pt,
               gobble=2,
               frame=lines,
               framesep=2mm]{python}
    def Solve2(q):
        msr = q.measure()[0]
        one_count = 0
        for q in msr:
            if q == '1': one_count += 1
        if one_count == 1:
            return 'W'
        else:
            return 'GHZ'
    Solve2(GHZ)
\end{minted}



\subsection{Различение состояний 2 (2 балла)}

Дано $2$ кубита, которые могут быть в одном из двух состояний:

$$\Ket{S_0} = \frac{1}{2}(\Ket{00} + \Ket{01} + \Ket{10} + \Ket{11})$$
$$\Ket{S_1} = \frac{1}{2}(\Ket{00} - \Ket{01} + \Ket{10} - \Ket{11})$$
$$\Ket{S_2} = \frac{1}{2}(\Ket{00} + \Ket{01} - \Ket{10} - \Ket{11})$$
$$\Ket{S_3} = \frac{1}{2}(\Ket{00} - \Ket{01} - \Ket{10} + \Ket{11})$$


Требуется выполнить необходимые преобразования, чтобы точно различить эти четыре состояния. Возвращать требуется индекс состояния (от $0$ до $3$). 
\\\\

Применяем оператор Адамара для обоих кубитов и измеряем получившиеся состояния.\\

\begin{equation*}
H^2 = \frac{1}{2}
\begin{pmatrix}
1 & 1 & 1 & 1\\
1 & -1 & 1 & -1\\
1 & 1 & -1 & -1\\
1 & -1 & 1 & -1
\end{pmatrix}
\end{equation*}

\begin{equation*}
H^2\Ket{S_0} = \frac{1}{4}
\begin{pmatrix}
1 & 1 & 1 & 1\\
1 & -1 & 1 & -1\\
1 & 1 & -1 & -1\\
1 & -1 & 1 & -1
\end{pmatrix}
\times
\begin{pmatrix}
1 \\
1 \\
1 \\
1
\end{pmatrix}
=
\begin{pmatrix}
1 \\
0 \\
0 \\
0
\end{pmatrix}
\end{equation*}

\begin{equation*}
H^2\Ket{S_1} = \frac{1}{4}
\begin{pmatrix}
1 & 1 & 1 & 1\\
1 & -1 & 1 & -1\\
1 & 1 & -1 & -1\\
1 & -1 & 1 & -1
\end{pmatrix}
\times
\begin{pmatrix}
1 \\
-1 \\
1 \\
-1
\end{pmatrix}
=
\begin{pmatrix}
0 \\
1 \\
0 \\
0
\end{pmatrix}
\end{equation*}

\begin{equation*}
H^2\Ket{S_2} = \frac{1}{4}
\begin{pmatrix}
1 & 1 & 1 & 1\\
1 & -1 & 1 & -1\\
1 & 1 & -1 & -1\\
1 & -1 & 1 & -1
\end{pmatrix}
\times
\begin{pmatrix}
1 \\
1 \\
-1 \\
-1
\end{pmatrix}
=
\begin{pmatrix}
0 \\
0 \\
1 \\
0
\end{pmatrix}
\end{equation*}


\begin{equation*}
H^2\Ket{S_4} = \frac{1}{4}
\begin{pmatrix}
1 & 1 & 1 & 1\\
1 & -1 & 1 & -1\\
1 & 1 & -1 & -1\\
1 & -1 & 1 & -1
\end{pmatrix}
\times
\begin{pmatrix}
1 \\
-1 \\
-1 \\
1
\end{pmatrix}
=
\begin{pmatrix}
0 \\
0 \\
0 \\
1
\end{pmatrix}
\end{equation*}

\begin{minted}[mathescape,
               linenos,
               numbersep=5pt,
               gobble=2,
               frame=lines,
               framesep=2mm]{python}
    def Solve3(q):
        global circuit
        circuit.initialize(q)
        circuit.h(0)
        circuit.h(1)
    
        state = Statevector(circuit)
        msr = state.measure()[0]
        if msr == '00':
            return 0
        elif msr == '01':
            return 1
        elif msr == '10':
            return 2
        elif msr == '11':
            return 3
    
    circuit = QuantumCircuit(2)
    print(Solve3(S3))
\end{minted}





\subsection{Написание оракула 1 (2 балла)}

Требуется реализовать квантовый оракул на $N$ кубитах ($1 \le N \le 8$), который реализует следующую функцию: $f(\pmb{x}) = (\pmb{b}\pmb{x}) \mod 2$, где  $\pmb{b} \in \{0,1\}^N$ вектор битов и  $\pmb{x}$ вектор кубитов. Выход функции записать в кубит $\pmb{y}$. Количество кубитов $N$ ($1 \le N \le 8$). 
\\\\
Заготовка для кода:
\begin{lstlisting}
namespace Solution {
        open Microsoft.Quantum.Primitive;
        open Microsoft.Quantum.Canon;
        operation Solve (x : Qubit[], y : Qubit, b : Int[]) : ()
        {
            body
            {

            }
        }
}
\end{lstlisting}

\end{document}